\documentclass[10pt, a4paper]{article}
% especifico márgenes manualmente
\usepackage[paper=a4paper, left=1.5cm, right=1.5cm, bottom=1.5cm, top=3.5cm]{geometry}
% codificación ISO-8859-1
\usepackage[latin1]{inputenc}
% separación silábica en castellano
\usepackage[spanish]{babel}
% paquetes y caratula de algo2
\usepackage{aed2-symb,aed2-itef,aed2-tad,caratula}

\begin{document}

% Estos comandos deben ir antes del \maketitle
\materia{Algoritmos y Estructuras de Datos II} % obligatorio
\submateria{Primer Cuatrimestre de 2015} % opcional
\titulo{Trabajo Práctico 1} % obligatorio
\subtitulo{Especificación DCNet} % opcional
\grupo{Grupo 24} % opcional 


\integrante{Fernando Frassia}{340/13}{ferfrassia@gmail.com} % obligatorio 
\integrante{Rodrigo Seoane Quilne}{910/11}{seoane.raq@gmail.com}
\integrante{Sebastian Matias Giambastiani}{916/12}{sebastian.giambastiani@hotmail.com}
\integrante{}{}{}



\maketitle

% compilar 2 veces para actualizar las referencias
\tableofcontents

\pagebreak
\newpage

\section{Aclaraciones}
$\bullet$ \tadNombre {TDC} son todos los caminos completos posibles de una computadora a otra.

$\bullet$ \tadNombre{caminoParcial} genera una secuencia de tuplas (c1, i1, i2, c2). En el último elemento de la secuencia, se encuentra la información de dónde está el paquete actualmente (c1), cuál es la próxima computadora a la que irá (c2), y cuales son las interfaces que las conectan (i1 e i2 respectivamente). Notar que caminoParcial no distingue entre un paquete que llegó a su destino y un paquete que está en la última computadora antes de llegar a su destino. Esto es por un tema de tipos (dado que la última computadora no puede ser agregada como una tupla (c, i, i, c), por eso es que existe $\pi$$_3$ en el observador infoP, el cual devuelve true cuando p está en su destino, y false cuando no. También vale aclarar que en $\pi$$_1$ se encuentra su computadora origen (es decir, donde se encoló), y en $\pi$$_2$ su computadora destino.

$\bullet$ Se decidió que las computadoras no puedan estar conectadas consigo mismas

$\bullet$ Si bien el observador caminoParcial devuelve el camino mínimo de un paquete (a medida que este viaja), se decidió que el camino mínimo a seguir (caminoTotal) se genere en la instancia en que se encola dicho paquete. 

$\bullet$ \tadNombre{metoInterfaces} toma una Secu(Compu) y devuelve una Secu(Compu, Interfaz, Interfaz, Compu). No logramos que entrara la signatura en la hoja. Hay un pequeño abuso de notación al no escribir la palabra \tadNombre{tupla} pero es porque así iba a entrar menos en la hoja y por ende entenderse menos.

$\bullet$ \tadNombre{encolar} no representa una cola ni trabaja con el TAD \tadNombre {cola}, sí hay un comportamiento tipo 'cola' en su axiomatización. La razón de su nombre es porque es como que 'encola' paquetes en una computadora. Pero no hicimos una Cola y tampoco nos interesó observar, desde los observadores, quienes son los paquetes en espera (sí precisamos esta información en un momento y la obtuvimos mediante otra operación). Solo nos interesó saber cuántos había en espera en cada computadora. 
 
 $\bullet$ En la restricción de \tadNombre{encolar}, la operación hayConexión?(laRed(d), $c_1$, $c_2$) ya chequea que $c_1$ y $c_2$ sean distintas. Por eso no está explicito en la restricción.
 
 $\bullet$ \tadNombre{paquetesDe} y \tadNombre{paquetesDe2} devuelven el conjunto de paquetes 'en transito' de una computadora, es decir, no toman en cuenta los que sí están en esa computadora pero ya llegaron a su destino.
 

%RenombresBegin
\section{Renombres}

\tadNombre{Interfaz} es \tadNombre{Nat}

\tadNombre{Compu} es \tadNombre{Nat}

\tadNombre{Paquete} es \tadNombre{Tupla(Nat, Nat), el $\pi$$_1$ de la tupla es la prioridad del paquete, y el $\pi$$_2$ es su identificador personal}

%\tadNombre{} es \tadNombre{}
%RenombresEnd

%TADSBegin

%SecuExtendidoBegin
\section{\tadNombre {Operaciones Auxiliares}}

%\begin{tad}{\tadNombre{}}
%\tadIgualdadObservacional{}{}{}{}
%\tadParametrosFormales{\tadGeneros{$\alpha$}}
%\tadGeneros{Secu($\alpha$)}

%\tadExporta{Secu, generadores, observadores}
%\tadUsa{}

%\tadObservadores
%\tadGeneradores
\tadOtrasOperaciones
\tadAlinearFunciones{agATodos}{Secu($\alpha$)/s1, Secu($\alpha$)/s2}

\tadOperacion{aConjunto}{Secu($\alpha$)}{Conj($\alpha$)}{}

\tadOperacion{siguiente}{Secu($\alpha$)/s1, Secu($\alpha$)/s2}{$\alpha$}{long($s_1$) $\textless$ long($s_2$)}

\tadOperacion{masCorto}{Conj(Secu($\alpha$))/cs}{Secu($\alpha$)}{$\neg$$\emptyset$?(cs)}

\tadOperacion{agATodos}{$\alpha$, Conj(Secu($\alpha$))}{Conj(Secu($\alpha$))}{}

\tadAxiomas[\paratodo{$\alpha$}{e}, \paratodo{Conj($\alpha$)}{c}, \paratodo{Secu($\alpha$)}{s, s1, s2}. \paratodo{Conj(Secu($\alpha$))}{cs}]
\tadAlinearAxiomas{masChica?(s1, s2)}

\tadAxioma{aConjunto(s)}{\IF vacia?(s) THEN $\emptyset$ ELSE Ag(prim(s), aConjunto(fin(s))) FI}

\tadAxioma{siguiente($s_1$, $s_2$)}{\IF vacia?($s_1$) THEN prim($s_2$) ELSE siguiente(fin($s_1$), fin($s_2$)) FI}

\tadAxioma{masCorto(cs)}{\IF $\#$(cs) = 1 THEN dameUno(cs) ELSE {\IF long(dameUno(cs)) $\textless$ long(dameUno(SinUno(cs))) THEN masCorto(cs - dameUno(sinUno(cs))) ELSE masCorto(sinUno(cs)) FI} FI}

\tadAxioma{agATodos(e, cs)}{\IF $\emptyset$?(cs) THEN $\emptyset$ ELSE Ag((e $\bullet$ dameUno(cs)), agATodos(e, sinUno(cs))) FI}


%\end{tad}
%SecuExtendidoEnd
\newpage

%RedBegin
\section{TAD \tadNombre{Red}}

\begin{tad}{\tadNombre{Red}}
\tadIgualdadObservacional{r1}{r2}{Red}{compus($r_1$) \igobs compus($r_2$) $\yluego$ \\ ($\forall$ c: Compu) \\ $[$(c $\in$ compus($r_1$) $\impluego$ (interfacesDe($r_1$, c) \igobs interfacesDe($r_2$, c))) $\yluego$ \\ ($\forall$ i:Interfaz) \\ $[$(c $\in$ compus($r_1$) $\yluego$ i $\in$ interfacesDe($r_1$, c) $\impluego$ (iLibre?($r_1$, c, i) \igobs iLibre?($r_2$, c, i))) $\yluego$ \\ (c $\in$ compus($r_1$) $\yluego$ i $\in$ interfacesDe($r_1$, c) $\yluego$ $\neg$iLibre?($r_1$, c, i) $\impluego$ (conectadoA($r_1$, c, i) \igobs conectadoA($r_2$, c, i)))$]$$]$}
\tadGeneros{Red}


\tadExporta{Red, generadores, observadores}
\tadUsa{\tadNombre{Bool}, \tadNombre{Conj($\alpha$)}, \tadNombre{Compu}, \tadNombre{Interfaz}, \tadNombre{Secu($\alpha$)}}

\tadObservadores
\tadAlinearFunciones{interfacesDe}{Red/r, Compu/c, Interfaz/i}
\tadOperacion{compus}{Red}{Conj(Compu)}{}
\tadOperacion{interfacesDe}{Red/r, Compu/c}{Conj(Interfaz)}{c $\in$ compus(r)}
\tadOperacion{conectadoA}{Red/r, Compu/c, Interfaz/i}{Compu}{c $\in$ compus(r) $\yluego$ i $\in$ interfacesDe(r,c) $\yluego$ $\neg$ iLibre?(r, c, i)}
\tadOperacion{iLibre?}{Red/r, Compu/c, Interfaz/i}{Bool}{c $\in$ compus(r) $\yluego$ i $\in$ interfacesDe(r, c)}

\tadGeneradores
\tadAlinearFunciones{conectar}{Red/r, Compu/c1, Compu/c2, Interfaz/i1, Interfaz/i2}
\tadOperacion{crear}{}{Red}{}
\tadOperacion{agCompu}{Red/r, Compu/c, Conj(Interfaz)}{Red}{c $\notin$ compus(r)}
\tadOperacion{conectar}{Red/r, Compu/c1, Compu/c2, Interfaz/i1, Interfaz/i2}{Red}{$c_1$ $\neq$ $c_2$ $\wedge$ $\{$$c_1$, $c_2$$\}$ $\subseteq$ compus(r) $\yluego$ $c_1$ $\notin$ compusDirectas(r,$c_2$) $\wedge$ $c_2$ $\notin$ compusDirectas(r,$c_1$) $\wedge$ (($i_1$ $\in$ interfacesDe(r,$c_1$) $\wedge$ $i_2$ $\in$ interfacesDe(r,$c_2$)) $\yluego$ iLibre?(r,$c_1$,$i_1$) $\wedge$ iLibre?(r,$c_2$,$i_2$))} 

\tadOtrasOperaciones
\tadAlinearFunciones{conjHayConexion?}{Red/r, Conj(Compu)/cc1, Compu/c, Conj(Compu)/cc2}

\tadOperacion{iOcupadas}{Red/r, Compu/c}{Conj(Interfaz)}{c $\in$ compus(r)}

\tadOperacion{iOcupadas2}{Red/r, Compu/c, Conj(Interfaz)/ci}{Conj(Interfaz)}{c $\in$ compus(r) $\yluego$ $c_i$ $\subseteq$ interfacesDe(r,c)}

\tadOperacion{hayConexion?}{Red/r, Compu/c1, Compu/c2}{Bool}{$\{$$c_1$, $c_2$$\}$ $\subseteq$ compus(r)}

\tadOperacion{hayConexion2?}{Red/r, Compu/c1, Compu/c2, Conj(Compu)/cc}{Bool}{($\{$$c_1$, $c_2$$\}$ $\cup$ cc) $\subseteq$ compus(r)}

\tadOperacion{conjHayConexion?}{Red/r, Conj(Compu)/cc1, Compu/c, Conj(Compu)/cc2}{Bool}{($\{$c$\}$ $\cup$ cc1 $\cup$ cc2) $\subseteq$ compus(r)}

\tadOperacion{compusDirectas}{Red/r, Compu/c}{Conj(Compu)}{c $\in$ compus(r)}

\tadOperacion{compusDirectas2}{Red/r, Compu/c, Conj(Interfaz)/ci}{Conj(Compu)}{c $\in$ compus(r) $\yluego$ ci $\subseteq$ iOcupadas(r, c)}

\tadOperacion{TDC}{Red/r, Compu/c1, Compu/c2}{Conj(Secu(Compu))}{$\{$$c_1$, $c_2$$\}$ $\subseteq$ compus(r)}

\tadOperacion{TDC2}{Red/r, Compu/c1, Compu/c2, Secu(Compu)/sc}{Conj(Secu(Compu))}{$\{$$c_1$, $c_2$$\}$ $\subseteq$ compus(r)}

\tadOperacion{conjTDC}{Red/r, Conj(Compu)/cc, Compu/c, Secu(Compu)/sc}{Conj(Secu(Compu))}{Ag(c, cc) $\subseteq$ compus(r)}

\tadOperacion{suInterfaz}{Red/r, Compu/c1, Compu/c2}{Interfaz}{$\{$$c_1$, $c_2$$\}$ $\subseteq$ compus(r) $\yluego$ $c_2$ $\in$ compusDirectas(r, $c_1$)}

\tadOperacion{suInterfaz2}{Red/r, Compu/c1, Compu/c2, Conj(Interfaz)/ci}{Interfaz}{$\{$$c_1$, $c_2$$\}$ $\subseteq$ compus(r) $\yluego$ ci $\subseteq$ iOcupadas(r, $c_1$)}

\tadOperacion{metoInterfaces}{Red/r, Secu(Compu)/sc}{Secu(Compu, Interfaz, Interfaz, Compu)}{$\neg$vacia?(sc)}
  

\tadAxiomas[\paratodo{Red}{r}, \paratodo{Compu}{c, c1, c2, c3}, \paratodo{Interfaz}{i, i1, i2, i3}, \paratodo{Conj(Interfaz)}{ci}, \paratodo{Conj(Compu)}{cc, cc1, cc2}, \paratodo{Secu(Compu)}{sc}]
\tadAlinearAxiomas{conectadoA(conectar(r, c1, c2, i1, i2), c3, i3)}

\tadAxioma{compus(crear())}{$\emptyset$}
\tadAxioma{compus(AgCompu(r, c, ci))}{Ag(c , compus(r))}
\tadAxioma{compus(conectar(r, $c_1$, $c_2$, $i_1$, $i_2$))}{compus(r)}

\tadAxioma{interfacesDe(agCompu(r, $c_1$, ci), $c_2$)}{\IF $c_1$ = $c_2$ THEN ci ELSE interfacesDe(r, $c_2$) FI}
\tadAxioma{interfacesDe(conectar(r, $c_1$, $c_2$, $i_1$, $i_2$), $c_3$)}{interfacesDe(r, $c_3$)}

\tadAxioma{conectadoA(agCompu(r, $c_1$, ci), $c_2$, $i_2$)}{conectadoA(r, $c_2$, $i_2$)}
\tadAxioma{conectadoA(conectar(r, $c_1$, $c_2$, $i_1$, $i_2$), $c_3$, $i_3$)}{\IF $c_3$ = $c_1$ $\wedge$ $i_3$ = $i_1$ THEN $c_2$ ELSE {\IF $c_3$ = $c_2$ $\wedge$ $i_3$ = $i_2$ THEN $c_1$ ELSE conectadoA(r, $c_3$, $i_3$) FI} FI}

\tadAxioma{iLibre?(agCompu(r, $c_1$, ci), $c_2$, i)}{\IF $c_1$ = $c_2$ THEN true ELSE iLibre?(r, $c_2$, i) FI}
\tadAxioma{iLibre?(conectar(r, $c_1$, $c_2$, $i_1$, $i_2$), $c_3$, $i_3$)}{\IF $c_3$ = $c_1$ $\wedge$ $i_3$ = $i_1$ THEN false ELSE {\IF $c_3$ = $c_2$ $\wedge$ $i_3$ = $i_2$ THEN false ELSE iLibre?(r, $c_3$, $i_3$) FI} FI}

\tadAxioma{iOcupadas(r, c)}{iOcupadas2(r, c, interfacesDe(r, c))}

\tadAxioma{iOcupadas2(r, c, ci)}{\IF $\emptyset$?(ci) THEN $\emptyset$ ELSE {\IF $\neg$ iLibre?(r, c, dameUno(ci)) THEN Ag(dameUno(ci), iOcupadas2(r, c, sinUno(ci))) ELSE iOcupadas2(r, c, sinUno(ci)) FI} FI}

\tadAxioma{hayConexion?(r, $c_1$, $c_2$)}{hayConexion2?(r, $c_1$, $c_2$, $\emptyset$)}

\tadAxioma{hayConexion2?(r, $c_1$, $c_2$, cc)}{\IF $c_2$ $\in$ compusDirectas(r, $c_1$) THEN true ELSE conjHayConexion?(r, compusDirectas(r, $c_1$) - cc, $c_2$, Ag($c_1$, cc)) FI} 

\tadAxioma{conjHayConexion?(r, $cc_1$, c, $cc_2$)}{\IF $\emptyset$?($cc_1$) THEN false ELSE hayConexion2?(r, dameUno($cc_1$), c, $cc_2$) $\vee$ conjHayConexion?(r, sinUno($cc_1$), c, $cc_2$) FI}

\tadAxioma{compusDirectas(r, c)}{compusDirectas2(r, c, iOcupadas(r, c))}

\tadAxioma{compusDirectas2(r, c, ci)}{\IF $\emptyset$?(ci) THEN $\emptyset$ ELSE Ag((conectadoA(r, c, dameUno(ci))), compusDirectas2(r, c, sinUno(ci))) FI}

\tadAxioma{TDC(r, $c_1$, $c_2$)}{agATodos($c_1$, TDC2(r, $c_1$, $c_2$, $\textless$$\textgreater$))}

\tadAxioma{TDC2(r, $c_1$, $c_2$, sc)}{\IF $c_2$ $\in$ compusDirectas(r, $c_1$) THEN $\{$sc $\&$ $\textless$$c_1$, $c_2$$\textgreater$$\}$ ELSE conjTDC(r, compusDirectas(r, $c_1$) - aConjunto(sc), $c_2$, sc  $\circ$ $c_1$) FI}

\tadAxioma{conjTDC(r, cc, c, sc)}{\IF $\emptyset$?(cc) THEN $\emptyset$ ELSE TDC2(r, dameUno(cc), c, sc) $\bigcup$ conjTDC(r, sinUno(cc), c, sc) FI}

\tadAxioma{suInterfaz(r, $c_1$, $c_2$)}{suInterfaz2(r, $c_1$, $c_2$, iOcupadas(r, $c_1$))}

\tadAxioma{suInterfaz2(r, $c_1$, $c_2$, ci)}{\IF conectadoA(r, $c_1$, dameUno(ci)) = $c_2$ THEN dameUno(ci) ELSE suInterfaz2(r, $c_1$, $c_2$, sinUno(ci)) FI}

\tadAxioma{metoInterfaces(r, sc)}{\IF vacia?(fin(sc)) THEN $\textless$$\textgreater$ ELSE (prim(sc), suInterfaz(r, prim(sc), prim(fin(sc))), suInterfaz(r, prim(fin(sc)), prim(sc)), prim(fin(sc))) $\bullet$ metoInterfaces(r, fin(sc)) FI}


\end{tad}
%RedEnd

\newpage

%DCNetBegin
\section{TAD \tadNombre{DCNet}}

\begin{tad}{\tadNombre{DCNet}}
\tadIgualdadObservacional{d1}{d2}{DCNet}{laRed($d_1$) $\igobs$ laRed($d_2$)  $\wedge$ \\ paquetes($d_1$) $\igobs$ paquetes($d_2$) $\yluego$ \\ $[$($\forall$c: Compu) (c $\in$ compus(laRed($d_1$)) $\impluego$ (cantEnviados($d_1$, c) $\igobs$ cantEnviados($d_2$, c))) $\wedge$ \\ ($\forall$p: Paquete) (p $\in$ paquetes($d_1$) $\impluego$ (infoP($d_1$, p) $\igobs$ infoP($d_2$, p) $\wedge$ caminoParcial($d_1$, p) $\igobs$ caminoParcial($d_2$, p)))$]$}
\tadGeneros{DCNet}

\tadExporta{DCNet, generadores, observadores}
\tadUsa{\tadNombre{Red}, \tadNombre{Secu($\alpha$)}, \tadNombre{Conjunto($\alpha$)}, \tadNombre{Nat}, \tadNombre{Bool}, \tadNombre{Paquete}, \tadNombre{Tupla}}

\tadObservadores
\tadAlinearFunciones{cantEnviados}{DCNet/d, Compu/c}
\tadOperacion{laRed}{DCNet}{Red}{}
\tadOperacion{paquetes}{DCNet}{Conj(Paquete)}{}
\tadOperacion{infoP}{DCNet/d, Paquete/p}{(Compu, Compu, Bool)}{p $\in$ paquetes(d)}
\tadOperacion{cantEnviados}{DCNet/d, Compu/c}{Nat}{c $\in$ compus(laRed(d))}
\tadOperacion{caminoParcial}{DCNet/d, Paquete/p}{Secu(Compu, Interfaz, Interfaz, Compu)}{p $\in$ paquetes(d)}

\tadGeneradores
\tadAlinearFunciones{pasarSeg}{DCNet/d, Compu/c1, Compu/c2, Paquete/p}
\tadOperacion{iniciar}{Red}{DCNet}{}
\tadOperacion{encolar}{DCNet/d, Compu/c1, Compu/c2, Paquete/p}{DCNet}{$[$($\forall$ $p_2$: Paquete) ($p_2$ $\in$ paquetes(d) $\Rightarrow$ $\pi$$_2$($p_2$) $\neq$ $\pi$$_2$(p))$]$  $\wedge$ $\{$$c_1$, $c_2$$\}$ $\subseteq$ compus(laRed(d)) $\yluego$ hayConexion?(laRed(d), $c_1$, $c_2$)}
\tadOperacion{pasarSeg}{DCNet}{DCNet}{}



\tadOtrasOperaciones
\tadAlinearFunciones{conjMasEnviante}{DCNet/d, Compu/c1, Compu/c2, Paquete/p}
\tadOperacion{masEnviante}{DCNet/d}{Compu}{$\neg$$\emptyset$?(compus(laRed(d)))}
\tadOperacion{masEnviante2}{DCNet/d, Conj(Compu)/cc}{Compu}{cc $\subseteq$ compus(laRed(d)) $\wedge$ $\neg$ $\emptyset$?(cc)}
\tadOperacion{conjMasEnviante}{DCNet/d, Conj(Compu)/cc, Compu/c}{Conj(Compu)}{Ag(c, cc) $\subseteq$ compus(laRed(d))}
\tadOperacion{caminoTotal}{DCNet/d, Paquete/p}{Secu(Compu, Interfaz, Interfaz, Compu)}{p $\in$ paquetes(d)}
\tadOperacion{paquetesDe}{DCNet, Compu}{Conj(Paquete)}{}
\tadOperacion{paquetesDe2}{DCNet/d, Compu, Conj(Paquete)/cp}{Conj(Paquete)}{cp $\subseteq$ paquetes(d)}

\tadOperacion{masPrioritario}{Conj(Paquete)/cp}{Paquete}{$\neg$$\emptyset$?(cp)}


\tadAxiomas[\paratodo{Red}{r}, \paratodo{DCNet}{d}, \paratodo{Compu}{c, c1, c2, c3}, \paratodo{Paquete}{p}, \paratodo{Conj(Compu)}{cc}, \paratodo{Conj(Paquete)}{cp}]
\tadAlinearAxiomas{caminoParcial(encolar(d, c1, c2, p1), p2)}
\tadAxioma{laRed(iniciar(r))}{r}
\tadAxioma{laRed(encolar(d, $c_1$, $c_2$, p))}{laRed(d)}
\tadAxioma{laRed(pasarSeg(d))}{laRed(d)}

\tadAxioma{paquetes(iniciar(r))}{$\emptyset$}
\tadAxioma{paquetes(encolar(d, $c_1$, $c_2$, p))}{Ag(p, paquetes(d))}
\tadAxioma{paquetes(pasarSeg(d))}{paquetes(d)}

\tadAxioma{infoP(encolar(d, $c_1$, $c_2$, $p_1$), $p_2$)}{\IF $p_1$ = $p_2$ THEN ($c_1$, $c_2$, false) ELSE infoP(d, $p_2$) FI}
\tadAxioma{infoP(pasarSeg(d), p)}{\IF $\pi$$_4$(ult(caminoParcial(d, p))) = $\pi$$_2$(infoP(d, p)) $\wedge$ \\ $\neg$$\pi$$_3$(infoP(d, p)) $\yluego$ \\ masPrioritario(paquetesDe(d, $\pi$$_1$(ult(caminoParcial(d, p))))) = p\\ THEN ($\pi$$_1$(infoP(d, p)), $\pi$$_2$(infoP(d, p)), true) ELSE infoP(d, p) FI}

\tadAxioma{cantEnviados(iniciar(r), c)}{0}
\tadAxioma{cantEnviados(encolar(d, $c_1$, $c_2$, p), $c_3$)}{cantEnviados(d, $c_3$)}
\tadAxioma{cantEnviados(pasarSeg(d), c)}{\IF $\#$paquetesDe(d, c) = 0 THEN cantEnviados(d, c) ELSE cantEnviados(d, c) + 1 FI}

\tadAxioma{caminoParcial(encolar(d, $c_1$, $c_2$, $p_1$), $p_2$)}{\IF $p_1$ = $p_2$ THEN $\textless$prim(caminoTotal(encolar(d, $c_1$, $c_2$, $p_1$), $p_2$))$\textgreater$ ELSE caminoParcial(d, $p_2$) FI}

\tadAxioma{caminoParcial(pasarSeg(d), p)}{\IF $\pi$$_4$(ult(caminoParcial(d, p))) = $\pi$$_2$(infoP(d, p)) THEN caminoParcial(d, p) ELSE {\IF masPrioritario(paquetesDe(d, $\pi$$_1$(ult(caminoParcial(d, p))))) = p THEN caminoParcial(d, p) $\circ$ siguiente(caminoParcial(d, p), caminoTotal(d, p))  ELSE caminoParcial(d, p) FI} FI}

\tadAxioma{masEnviante(d)}{dameUno(conjMasEnviante(d, compus(laRed(d)), masEnviante2(d, compus(laRed(d)))))}

\tadAxioma{masEnviante2(d, cc)}{\IF \#(cc) = 1 THEN dameUno(cc) ELSE {\IF cantEnviados(d, dameUno(cc)) $\geq$ cantEnviados(d, dameUno(sinUno(cc))) THEN masEnviante2(d, cc - dameUno(sinUno(cc))) ELSE masEnviante2(d, cc - dameUno(cc)) FI} FI}

\tadAxioma{conjMasEnviante(d, cc, c)}{\IF $\emptyset$?(cc) THEN  $\emptyset$ ELSE {\IF cantEnviados(d, dameUno(cc)) = cantEnviados(d, c) THEN Ag(dameUno(cc), conjMasEnviante(d, sinUno(cc), c)) ELSE conjMasEnviante(d, sinUno(cc), c) FI} FI}

\tadAxioma{caminoTotal(d, p)}{metoInterfaces(laRed(d), masCorto(TDC(laRed(d), $\pi$$_1$(infoP(d, p)), $\pi$$_2$(infoP(d, p)))))}

\tadAxioma{paquetesDe(d, c)}{paquetesDe2(d, c, paquetes(d))}

\tadAxioma{paquetesDe2(d, c, cp)}{\IF $\emptyset$?(cp) THEN $\emptyset$ ELSE {\IF $\pi$$_1$(ult(caminoParcial(d, dameUno(cp)))) = c $\wedge$ \\ $\neg$$\pi$$_3$(infoP(d, dameUno(cp))) \\ THEN Ag(dameUno(cp), paquetesDe2(d, c, sinUno(cp))) ELSE paquetesDe2(d, c, sinUno(cp)) FI} FI}

\tadAxioma{masPrioritario(cp)}{\IF $\#$(cp) = 1 THEN dameUno(cp) ELSE {\IF $\pi$$_1$(dameUno(cp)) $\textgreater$ $\pi$$_1$(dameUno(sinUno(cp))) THEN masPrioritario(cp - dameUno(sinUno(cp))) ELSE masPrioritario(cp - dameUno(cp)) FI} FI}




\end{tad}
%DCNetEnd
%TADSEnd

\end{document}
